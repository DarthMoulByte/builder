#!/bin/sh

# report about status of build master

. "${0%/*}/../conf/default.conf"

usage() {
  >&2 echo ''
  >&2 echo 'build-master-status: report about status of build master'
  >&2 echo ''
  >&2 echo 'possible options:'
  >&2 echo '  -b|--broken $output:'
  >&2 echo '    Write broken packages to $output.'
  >&2 echo '  -h|--help:'
  >&2 echo '    Show this help and exit.'
  >&2 echo '  -n|--nice:'
  >&2 echo '    Write html output.'
  >&2 echo '  -o|--output $output:'
  >&2 echo '    Write to $output instead of stdout.'
  >&2 echo '  -s|--statistics $output:'
  >&2 echo '    Write statistics to $output.'
  [ -z "$1" ] && exit 1 || exit $1
}

eval set -- "$(
  getopt -o b:hno:s: \
    --long broken: \
    --long help \
    --long nice \
    --long output: \
    --long statistics: \
    -n "$(basename "$0")" -- "$@" || \
  echo usage
)"

output() {
  cat
}

make_nice() {
  cat
}

nice=false
broken_output=''
output_file=''
statistics_output=''

while true
do
  case "$1" in
    -b|--broken)
      shift
      broken_output="$1"
    ;;
    -h|--help)
      usage 0
    ;;
    -n|--nice)
      nice=true
      make_nice() {
        sed 's|$|<br>|'
      }
    ;;
    -o|--output)
      shift
      output_file="$1"
      output() {
        cat >> "${output_file}"
      }
    ;;
    -s|--statistics)
      shift
      statistics_output="$1"
    ;;
    --)
      shift
      break
    ;;
    *)
      >&2 echo 'Whoops, forgot to implement option "'"$1"'" internally.'
      exit 42
    ;;
  esac
  shift
done

if [ $# -ne 0 ]; then
  >&2 echo 'Too many arguments.'
  usage
fi

stable="$(
  ls_master_mirror 'i686' | \
    grep -v 'testing$\|staging$' | \
    while read -r dir; do
      ls_master_mirror "i686/${dir}"
    done | \
    grep -c '\.pkg\.tar\.xz$'
  )"
tasks="$(
  grep -c '^\S\+ \S\+ \S\+ \S\+$' \
    "${work_dir}/build-list"
  )" || true
pending_packages="$(
  tr ' ' '.' < \
    "${work_dir}"/build-list | \
    while read -r package; do
      generate_package_metadata "${package}" &> /dev/null
      cat "${work_dir}/package-infos/${package%.*}.packages"
    done |
    wc -l
)"
staging="$(
  ls_master_mirror 'i686' | \
    grep 'staging$' | \
    while read -r dir; do
      ls_master_mirror "i686/${dir}"
    done | \
    grep -c '\.pkg\.tar\.xz$'
  )"
testing="$(
  ls_master_mirror 'i686' | \
    grep 'testing$' | \
    while read -r dir; do
      ls_master_mirror "i686/${dir}"
    done | \
    grep -c '\.pkg\.tar\.xz$'
  )"
broken="$(
  ls "${work_dir}/package-states/" | \
    grep -c '\.broken$'
  )" || true
blocked="$(
  ls "${work_dir}/package-states/" | \
    grep -c '\.blocked$'
  )" || true
locked="$(
  ls "${work_dir}/package-states/" | \
    grep -c '\.locked$'
  )" || true
loops="$(
  ls "${work_dir}/build-list.loops" | \
    grep -c '^loop_[0-9]\+$'
  )" || true
looped_packages="$(
  ls "${work_dir}/build-list.loops" | \
    grep '^loop_[0-9]\+$' | \
    sed "s|^|${work_dir}/build-list.loops/|" | \
    xargs -r cat | \
    sort -u | \
    wc -l
  )"

if [ -n "${output_file}" ]; then
  : > "${output_file}"
fi

printf 'The mirror master contains %d stable packages (vs. ca. %d planned).\n' \
  "${stable}" \
  "$((${staging}+${testing}+${pending_packages}))" | \
  make_nice | \
  output
printf 'The build list contains %d tasks (incl. broken: %d, leading to %d packages).\n' \
  "$((${tasks}-${broken}))" \
  "${tasks}" \
  "${pending_packages}" | \
  make_nice | \
  output
printf 'There are %d testing and %d staging packages.\n' \
  "${testing}" \
  "${staging}" | \
  output
printf 'There are %d broken package builds.\n' \
  "${broken}" | \
  make_nice | \
  output
if [ "${loops}" -ne 0 ]; then
  printf 'There are %d loops containing %d package builds.\n' \
    "${loops}" \
    "${looped_packages}" | \
    make_nice | \
    output
fi
if [ $((${broken}+${testing}+${staging})) -ne 0 ]; then
  printf '%.1f%% of all packages are broken.\n' \
    "$(
      echo "scale=10; 100*${broken}/(${broken}+${testing}+${staging})" | \
        bc
    )" | \
    make_nice | \
    output
fi
if [ $((${testing}+${staging}+${pending_packages}-${broken})) -ne 0 ]; then
  printf '%.1f%% of the planned work has been done.\n' \
    "$(
      echo "scale=10; 100*(${testing}+${staging})/(${testing}+${staging}+${pending_packages}-${broken})" | \
        bc
    )" | \
    make_nice | \
    output
fi

if [ -n "${statistics_output}" ]; then
  (
    [ -f "${statistics_output}" ] && \
      cat "${statistics_output}"
    printf '%s ' \
      "$(date +%s)" \
      "${stable}" \
      "${tasks}" \
      "${pending_packages}" \
      "${staging}" \
      "${testing}" \
      "${broken}" \
      "${loops}" \
      "${looped_packages}" \
      "${locked}" \
      "${blocked}" | \
      sed 's| $|\n|'
  ) | \
  tail -n 10080 | \
  sponge "${statistics_output}"
fi

if [ -n "${broken_output}" ]; then
  (
    if ${nice}; then
      printf '<html>\n<body>\n<a href="build-logs/">build logs</a><br>\n<table>\n<tr>'
      printf '<th>%s</th>' \
        'package' \
        'git revision' \
        'modification git revision' \
        'package repository' \
        'compilations' \
        'blocked'
      printf '</tr>\n'
    fi
    ls "${work_dir}/package-states" | \
      grep '\.broken$' | \
      sed 's|\.broken$||' | \
      if ${nice}; then
        sed 's|^\(\(.\+\)\.\([^.]\+\)\.\([^.]\+\)\.\([^.]\+\)\)$|\1 \2 \3 \4 \5|' | \
          while read -r sf pkg rev mod_rev repo; do
            printf '%s ' \
              "${pkg}" \
              "${rev}" \
              "${mod_rev}" \
              "${repo}" \
              "$(wc -l < "${work_dir}/package-states/${sf}.broken")"
            if [ -f "${work_dir}/package-states/${sf}.blocked" ]; then
              tr '\n' ' ' < "${work_dir}/package-states/${sf}.blocked"
            else
              printf '&nbsp;'
            fi
            printf '\n'
          done | \
          sort -k5n,5 | \
          while read -r pkg rev mod_rev repo count reason; do
            printf '<tr>'
            printf '<td>%s</td>' \
              "${pkg}" \
              "${rev}" \
              "${mod_rev}" \
              "${repo}" \
              "${count}" \
              "${reason}"
            printf '</tr>\n'
          done
      else
        cat
      fi
    if ${nice}; then
      printf '</table>\n</body>\n</html>\n'
    fi
  ) | \
    sponge "${broken_output}"
fi
