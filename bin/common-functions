#!/bin/bash

# contains functions used by more than one script

# TODO:
#  maybe source PKGBUILD instead of 'makepkg --printsrcinfo' and 'mksrcinfo'?

# find_pkgbuild repository package
# find the PKGBUILD of $package from $repository

find_pkgbuild() {

  local PKGBUILD='' repo file

  if [ -f "${repo_paths["archlinux32"]}/$2/$1/PKGBUILD" ]; then
    # If this package has some modification,
    repo="$(find_git_repository_to_package_repository "$2")"
    if ! [ -d "${repo_paths["${repo}"]}/$1" ]; then
      # create some dummy files if it is also new.
      mkdir -p "${repo_paths["${repo}"]}/$1/repos/$2-x86_64"
      touch "${repo_paths["${repo}"]}/$1/repos/$2-x86_64/PKGBUILD"
    fi
  fi

  for repo in "${!repo_paths[@]}"; do
    if [ "${repo}" == "archlinux32" ]; then
      # this is not a repository of packages
      continue
    fi
    if ! [ -d "${repo_paths["${repo}"]}/$1" ]; then
      continue
    fi
    PKGBUILD="$(
      ls "${repo_paths["${repo}"]}/$1/repos/$2-"*"/PKGBUILD" 2> /dev/null | \
        tr ' ' '\n' | \
        grep -v -- '-i686/PKGBUILD$' | \
        grep -v -- '-\(staging\|testing\)-[^/]\+/PKGBUILD$' | \
        sort | \
        tail -n1
    )"
    if [ -n "${PKGBUILD}" ]; then
      echo "${PKGBUILD}"
      break
    fi
  done
}

# apply customizations to a package
#  (to be executed in the package's directory)

# TODO:
#  mangle $arch in PKBUILDs to contain i486, i586, i686

apply_package_customizations() {
  if [ ! -f 'PKGBUILD' ]; then
    >&2 echo 'PKGBUILD not found.'
    pwd
    exit 1
  fi

  local repo package

  repo="$(pwd)"
  package="${repo%/*/*}"
  package="${package##*/}"
  repo="${repo##*/}"
  repo="${repo%-any}"
  repo="${repo%-x86_64}"

  if [ ! -f 'PKGBUILD.changes-applied' ]; then
    # add i686 to the arch list
    sed '/^arch=[^#]*any/!s|^\(arch=(\)\([^#]*)\)\s*\(#.*\)\?$|\1'"'i686'"' \2|' -i 'PKGBUILD'
    if [ -f "${repo_paths["archlinux32"]}/${repo}/${package}/PKGBUILD" ]; then
      # If this package has modifications (or is new), apply them now:
      # append PKGBUILD
      cat "${repo_paths["archlinux32"]}/${repo}/${package}/PKGBUILD" >> \
        'PKGBUILD'
      # copy (and overwrite) other files
      for file in "${repo_paths["archlinux32"]}/${repo}/${package}/"*; do
        if [ -f "${file}" ] && [ "${file##*/}" != 'PKGBUILD' ]; then
          cp "${file}" ./
        fi
      done
    fi
    touch 'PKGBUILD.changes-applied'
  fi
}

# find_repository_with_commit commit
# find the repository which has $commit

find_repository_with_commit() {

  local repository

  for repository in "${!repo_paths[@]}"; do
    if [ "$(git -C "${repo_paths["${repository}"]}" cat-file -t "$1" 2> /dev/null)" == "commit" ]; then
      echo "${repository}"
      return 0
    fi
  done
  >&2 echo "can't find repository with commit '$1'"
  exit 1

}

# find_git_repository_to_package_repository repository
# find the git repository which tracks the package repository $repository

find_git_repository_to_package_repository() {

  local repository

  for repository in "${!repo_paths[@]}"; do
    if [ "${repository}" == "archlinux32" ]; then
      continue
    fi
    if [ -n "$(
      (
        ls "${repo_paths["${repository}"]}/"*"/repos" | \
          grep -v ':$' | \
          sed 's|-[^-]\+$||' | \
          sort -u
        echo "$1"
      ) | \
        sort | \
        uniq -d
      )" ]; then
      echo "${repository}"
      return 0
    fi
  done
  >&2 echo "can't find git repository with package repository '$1'"
  exit 1

}

# package_locked_broken_or_blocked package git_revision mod_git_revision repository
# return if package - of given repository and revisions - is [locked or broken or blocked]

package_locked_broken_or_blocked() {
  [ -f "${work_dir}/package-states/$1.$2.$3.$4.locked" ] || \
    [ -f "${work_dir}/package-states/$1.$2.$3.$4.broken" ] || \
    [ -f "${work_dir}/package-states/$1.$2.$3.$4.blocked" ]
}

# generate_package_metadata $package $git_revision $mod_git_revision $repository
# or
# generate_package_metadata $package.$git_revision.$mod_git_revision.$repository
# generate the meta data files of a package (dependencies, built packages, ...)

generate_package_metadata() {

  local package="$1"
  local git_revision="$2"
  local mod_git_revision="$3"
  local repository="$4"
  local file_prefix file PKGBUILD

  if [ $# -eq 1 ]; then
    # second form
    repository="${package##*.}"
    package="${package%.*}"
    mod_git_revision="${package##*.}"
    package="${package%.*}"
    git_revision="${package##*.}"
    package="${package%.*}"
  fi

  file_prefix="${work_dir}/package-infos/${package}.${git_revision}.${mod_git_revision}"

  if [ -e "${file_prefix}.builds" ] && \
    [ -e "${file_prefix}.depends" ] && \
    [ -e "${file_prefix}.needs" ] && \
    [ -e "${file_prefix}.packages" ]; then
    return 0
  fi

  git -C "${repo_paths["$(find_repository_with_commit "${git_revision}")"]}" checkout "${git_revision}"
  git -C "${repo_paths["$(find_repository_with_commit "${mod_git_revision}")"]}" checkout "${mod_git_revision}"

  PKGBUILD="$(find_pkgbuild "${package}" "${repository}")"

  if [ ! -r "${PKGBUILD}" ]; then
    echo "can't find PKGBUILD to package '${package}' from repository '${repository}': '${PKGBUILD}'"
    exit 1
  fi

  (
    cd "${PKGBUILD%/*}"
    apply_package_customizations
    grep -q '\$CARCH' 'PKGBUILD' && \
      CARCH=i686 makepkg --printsrcinfo > \
        "${file_prefix}.SRCINFO" || \
      mksrcinfo -o "${file_prefix}.SRCINFO"
  )

  # otherwise this just calls for trouble
  sed -i '/=\s*$/d' "${file_prefix}.SRCINFO"

  # extract "builds" = provides \cup pkgname
  grep '^\('$'\t''provides\|pkgname\) = ' "${file_prefix}.SRCINFO" | \
    cut -d= -f2 | \
    sed 's|^\s\+||; s|[<>]$||' | \
    sort -u > \
    "${file_prefix}.builds"

  # extract "packages" = pkgname
  grep '^pkgname = ' "${file_prefix}.SRCINFO" | \
    cut -d= -f2 | \
    sed 's|^\s\+||; s|[<>]$||' | \
    sort -u > \
    "${file_prefix}.packages"

  # extract "needs" = ( makedepends \cup checkdepends ) \setminus "builds"
  (
    grep '^'$'\t''\(makedepends\|checkdepends\) = ' "${file_prefix}.SRCINFO" | \
      cut -d= -f2 | \
      sed 's|^\s\+||; s|[<>]$||' | \
      sort -u
    sed 'p' "${file_prefix}.builds"
  ) | \
    sort | \
    uniq -u > \
    "${file_prefix}.needs"

  # extract "depends" = makedepends \cup checkdepends \cup depends
  (
    sed -n '/^pkgname = /q;/^'$'\t''depends = /p' "${file_prefix}.SRCINFO"
    grep '^'$'\t''\(makedepends\|checkdepends\) = ' "${file_prefix}.SRCINFO"
  ) | \
    cut -d= -f2 | \
    sed 's|^\s\+||; s|[<>]$||' | \
    sort -u > \
    "${file_prefix}.depends"

  rm "${file_prefix}.SRCINFO"

}

# delete_old_metadata
# delete old (=unneeded) meta data of packages

delete_old_metadata() {

  (
    ls -1 "${work_dir}/package-infos" | \
      sed '
        s|\.\([^.]\+\)\.\([^.]\+\)\.[^.]\+$| \1 \2|
      ' | \
      sort -u
    ls -1 "${work_dir}/package-states" | \
      sed '
        s|\.\([^.]\+\)\.\([^.]\+\)\(\.[^.]\+\)\{2\}$| \1 \2|
      ' | \
      sort -u | \
      sed 'p'
    cut -d' ' -f1,2,3 "${work_dir}/build-list" | \
      sed 'p'
  ) | \
    sort | \
    uniq -u | \
    while read -r pkg rev mod_rev; do
      rm -f "${work_dir}/package-infos/${pkg}.${rev}.${mod_rev}".*
    done
}

# official_or_community $package.$repo_revision.$mod_repo_revision.$repository
# print wether the specified package is an official package (print
# nothing) or a community package (print 'community-')

official_or_community() {
  local package="$1"
  local repository="${package##*.}"
  package="${package%.*}"
  local a32_rev="${package##*.}"
  package="${package%.*.*}"

  case "${repository}" in
    'community')
      echo 'community-'
      ;;
    'multilib')
      if ! git -C "${repo_paths['archlinux32']}" archive --format=tar "${a32_rev}" -- 'extra-from-multilib' | \
        tar -Ox | \
        grep -qFx "${package%.*.*.*}"; then
        echo 'community-'
      fi
      ;;
  esac
}

# remove_old_package_versions $package_file
# removes all other versions of $package_file in the current directory

remove_old_package_versions() {

  local package="$1"
  local pkgname="${package%-*-*-*.pkg.tar.xz}"

  ls | \
    grep "^${pkgname//./\\.}\(-[^-]\+\)\{3\}\.pkg\.tar\.xz\(\.sig\)\?\$" | \
    grep -v "^${package//./\\.}\(\.sig\)\?\$" | \
    xargs -rn1 rm

}
