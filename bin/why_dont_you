#!/bin/sh

# usage: why_dont_you $action $package1 $package2 ...

# investigate, why a certain operation is not done with certain packages

. "${0%/*}/../conf/default.conf"

action="$1"
shift

case "${action}" in

  'build')

    for pkg in "$@"; do
      grep "^$(str_to_regex "${pkg}") " "${work_dir}/build-list" | \
        while read -r package git_revision mod_git_revision repository; do

          if [ -f "${work_dir}/${package}.${git_revision}.${mod_git_revision}.${repository}.done" ] ||
            [ -f "${work_dir}/${package}.${git_revision}.${mod_git_revision}.${repository}.testing" ]; then
            echo 'has been built'
            continue
          fi

          if package_locked_broken_or_blocked "${package}" "${git_revision}" "${mod_git_revision}" "${repository}"; then
            echo 'is locked, broken or blocked'
            continue
          fi

          if [ -n "$(
            (
              cat "${work_dir}/package-infos/${package}.${git_revision}.${mod_git_revision}.needs"
              awk '{print $1 "." $2 "." $3}' "${work_dir}/build-list" | \
                sed "
                  s|^|${work_dir}/package-infos/|
                  s|\$|\.builds|
                " | \
                xargs -r cat | \
                sort -u
            ) | \
              sort | \
              uniq -d
            )" ]; then
            echo 'has unmet dependencies:'
            (
              cat "${work_dir}/package-infos/${package}.${git_revision}.${mod_git_revision}.needs"
              awk '{print $1 "." $2 "." $3}' "${work_dir}/build-list" | \
                sed "
                  s|^|${work_dir}/package-infos/|
                  s|\$|\.builds|
                " | \
                xargs -r cat | \
                sort -u
            ) | \
              sort | \
              uniq -d | \
              while read -r dep; do
                grep -Fx "${dep}" "${work_dir}/package-infos/"*".builds" | \
                  cut -d: -f1 | \
                  xargs -rn1 basename | \
                  cut -d. -f1
              done | \
              sort -u

            continue
          fi

          echo 'would be built'
        done

    done

  ;;

  'unstage')

    for pkg in "$@"; do

      if ! ls -1 "${work_dir}/package-states" | \
        grep -q "^$(str_to_regex "${pkg}")\(\.[^.]\+\)\{3\}\.done\$"; then
        printf 'Package "%s" is not in staging!\n' "${pkg}"
        continue
      fi

      dependent_packages="$(
        grep -xF "${pkg}" "${work_dir}/package-infos/"*".depends" | \
          cut -d: -f1 | \
          sed '
            s|^.*/||
            s|\.depends$||
          '
      )"

      build_list_items_file="$(mktemp)"
      dependent_packages_file="$(mktemp)"

      awk '{print $1 "." $2 "." $3 " " $4}' "${work_dir}/build-list" | \
        sort -u > \
        "${build_list_items_file}"

      printf '%s\n' "${dependent_packages}" | \
        sort -u > \
        "${dependent_packages_file}"

      dependent_still_on_build_list="$(
        join -1 1 -2 1 -o 1.1,1.2 \
          "${build_list_items_file}" \
          "${dependent_packages_file}"
      )"

      rm -f \
        "${build_list_items_file}" \
        "${dependent_packages_file}"

      if [ -n "${dependent_still_on_build_list}" ]; then
        printf 'The following packages are dependent on "%s", but still on the build list:\n' "${pkg}"
        echo "${dependent_still_on_build_list}"
        continue
      fi

      echo 'No dependencies left on build list.'
      echo "${dependent_packages}"

    done

  ;;

  *)
    >&2 printf 'unknown action "%s"\n' "${action}"
    exit 1

esac
